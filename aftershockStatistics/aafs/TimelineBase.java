package scratch.aftershockStatistics.aafs;

import java.util.List;
import java.util.ArrayList;

import scratch.aftershockStatistics.util.MarshalReader;
import scratch.aftershockStatistics.util.MarshalWriter;
import scratch.aftershockStatistics.util.MarshalException;


/**
 * Common base class for all timeline classes.
 * Author: Michael Barall 04/10/2018.
 *
 * The AAFS server maintains a timeline for each event it is tracking.
 */
public abstract class TimelineBase {

	//----- Constants and variables -----

	// Action codes that appear in the timeline entry.

	public static final int ACTCODE_TRACK = 1;
	public static final int ACTCODE_UNTRACK = 2;
	public static final int ACTCODE_FORECAST = 3;
	public static final int ACTCODE_ANALYST = 4;

	// Origin of this timeline entry.

	protected int origin;

	public static final int ORIGIN_MIN     = 1;
	public static final int ORIGIN_AUTO    = 1;		// Generated by automatic system
	public static final int ORIGIN_PDL     = 2;		// Injected from PDL notification
	public static final int ORIGIN_ANALYST = 3;		// Analyst intervention
	public static final int ORIGIN_SYNC    = 4;		// Synchronizing to Comcat or backup
	public static final int ORIGIN_MAX     = 4;

	// Analyst submitting this timeline entry, or "" if none.

	protected String submit_id;

	// Remark for this timeline entry, or "" if none.

	protected String remark;




	//----- Getters and setters -----

	public int get_origin () {
		return origin;
	}

	public String get_submit_id () {
		return submit_id;
	}

	public String get_remark () {
		return remark;
	}




	//----- Construction -----

	/**
	 * Default constructor does nothing.
	 */
	public TimelineBase () {}


	/**
	 * Construct from given values.
	 */
	public TimelineBase (int origin, String submit_id, String remark) {
		if (!( origin >= ORIGIN_MIN && origin <= ORIGIN_MAX )) {
			throw new IllegalArgumentException ("TimelineBase: Origin out-of-range: origin = " + origin);
		}
		if (!( submit_id != null )) {
			throw new NullPointerException ("TimelineBase: Parameter 'submit_id' is null");
		}
		if (!( remark != null )) {
			throw new NullPointerException ("TimelineBase: Parameter 'remark' is null");
		}

		this.origin = origin;
		this.submit_id = submit_id;
		this.remark = remark;
	}




	//----- Marshaling -----

	// Marshal version number.

	private static final int MARSHAL_VER_1 = 15001;

	private static final String M_VERSION_NAME = "TimelineBase";

	// Marshal type code.

	protected static final int MARSHAL_NULL = 15000;
	protected static final int MARSHAL_TRACK = 16001;
	protected static final int MARSHAL_UNTRACK = 17001;
	protected static final int MARSHAL_FORECAST = 18001;
	protected static final int MARSHAL_ANALYST = 19001;

	protected static final String M_TYPE_NAME = "ClassType";

	// Get the type code.

	protected abstract int get_marshal_type ();

	// Marshal object, internal.

	protected void do_marshal (MarshalWriter writer) {

		// Version

		writer.marshalInt (M_VERSION_NAME, MARSHAL_VER_1);

		// Contents

		writer.marshalInt    ("origin"   , origin   );
		writer.marshalString ("submit_id", submit_id);
		writer.marshalString ("remark"   , remark   );

	
		return;
	}

	// Unmarshal object, internal.

	protected void do_umarshal (MarshalReader reader) {
	
		// Version

		int ver = reader.unmarshalInt (M_VERSION_NAME, MARSHAL_VER_1, MARSHAL_VER_1);

		// Contents

		origin    = reader.unmarshalInt    ("origin"   );
		submit_id = reader.unmarshalString ("submit_id");
		remark    = reader.unmarshalString ("remark"   );

		return;
	}

	// Marshal object.

	public void marshal (MarshalWriter writer, String name) {
		writer.marshalMapBegin (name);
		do_marshal (writer);
		writer.marshalMapEnd ();
		return;
	}

	// Unmarshal object.

	public TimelineBase unmarshal (MarshalReader reader, String name) {
		reader.unmarshalMapBegin (name);
		do_umarshal (reader);
		reader.unmarshalMapEnd ();
		return this;
	}

	// Marshal object, polymorphic.

	public static void marshal_poly (MarshalWriter writer, String name, TimelineBase obj) {

		writer.marshalMapBegin (name);

		if (obj == null) {
			writer.marshalInt (M_TYPE_NAME, MARSHAL_NULL);
		} else {
			writer.marshalInt (M_TYPE_NAME, obj.get_marshal_type());
			obj.do_marshal (writer);
		}

		writer.marshalMapEnd ();

		return;
	}

	// Unmarshal object, polymorphic.

	public static TimelineBase unmarshal_poly (MarshalReader reader, String name) {
		TimelineBase result;

		reader.unmarshalMapBegin (name);
	
		// Switch according to type

		int type = reader.unmarshalInt (M_TYPE_NAME);

		switch (type) {

		default:
			throw new MarshalException ("TimelineBase.unmarshal_poly: Unknown class type code: type = " + type);

		case MARSHAL_NULL:
			result = null;
			break;

//		case MARSHAL_TRACK:
//			result = new TimelineBaseTrack();
//			result.do_umarshal (reader);
//			break;
//
//		case MARSHAL_UNTRACK:
//			result = new TimelineBaseUntrack();
//			result.do_umarshal (reader);
//			break;
//
//		case MARSHAL_FORECAST:
//			result = new TimelineBaseForecast();
//			result.do_umarshal (reader);
//			break;
//
//		case MARSHAL_ANALYST:
//			result = new TimelineBaseAnalyst();
//			result.do_umarshal (reader);
//			break;
		}

		reader.unmarshalMapEnd ();

		return result;
	}

}
